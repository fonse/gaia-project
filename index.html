<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gaia Project Board Generator</title>
</head>
<body>
  
  <main class="container">
    <div id="grid" style="margin: auto"></div>
  </main>

  <script src="static/svg.min.js"></script>
  <script src="static/honeycomb.min.js"></script>
  
  <script>
    /**
     * -------------------------------------------------------
     * Constants
     * -------------------------------------------------------
     */

    const Hex = Honeycomb.extendHex({
        size: 30,
        orientation: 'flat',
    });
    const Grid = Honeycomb.defineGrid(Hex);
    
    const planetSize = 30;
    const planetColors = {
      'terra': '#2080f0',
      'desert': '#f2ff00',
      'swamp': '#704100',
      'oxide': '#ff160a',
      'volcanic': '#ff9500',
      'ice': '#f8fff5',
      'titanium': '#6c757d',
      'transdim': '#a64dff',
      'gaia': '#00aa00',
    };

    const tileShiftX = {q: 5, r: -2, s: -3};
    const tileShiftY = {q: 3, r: -5, s: 2};

    const tileSpecs = [
      {
        number: 1,
        planets: [
          [-2,  0, 'desert'],
          [-1, -1, 'swamp'],
          [ 0,  2, 'oxide'],
          [ 1, -1, 'terra'],
          [ 1,  1, 'volcanic'],
          [ 2, -0, 'transdim'],
        ]
      },
      {
        number: 2,
        planets: [
          [-1, -2, 'volcanic'],
          [-1,  0, 'swamp'],
          [-1,  1, 'oxide'],
          [ 0, -2, 'titanium'],
          [ 1, -1, 'ice'],
          [ 1,  1, 'transdim'],
          [ 2,  0, 'desert'],
        ]
      },
      {
        number: 3,
        planets: [
          [-1, -1, 'gaia'],
          [-1,  1, 'terra'],
          [ 0, -2, 'transdim'],
          [ 0,  2, 'desert'],
          [ 1,  0, 'ice'],
          [ 2,  0, 'titanium'],
        ]
      },
      {
        number: 4,
        planets: [
          [-2,  0, 'ice'],
          [-1,  0, 'volcanic'],
          [ 0, -2, 'titanium'],
          [ 0, -1, 'oxide'],
          [ 1,  0, 'swamp'],
          [ 2,  1, 'terra'],
        ]
      },
      {
        number: 5,
        planets: [
          [-1, -1, 'gaia'],
          [-1,  1, 'volcanic'],
          [ 0, -2, 'ice'],
          [ 0,  2, 'desert'],
          [ 2, -1, 'transdim'],
          [ 2,  0, 'oxide'],
        ]
      },
      {
        number: 6,
        planets: [
          [-1, -1, 'swamp'],
          [ 0,  1, 'gaia'],
          [ 1, -2, 'transdim'],
          [ 1, -1, 'terra'],
          [ 1,  1, 'transdim'],
          [ 2,  1, 'desert'],
        ]
      },
      {
        number: 7,
        planets: [
          [-2, -1, 'transdim'],
          [-1,  0, 'gaia'],
          [ 0, -1, 'oxide'],
          [ 0,  2, 'titanium'],
          [ 1, -2, 'swamp'],
          [ 1,  0, 'gaia'],
        ]
      },
      {
        number: 8,
        planets: [
          [-1,  0, 'volcanic'],
          [-1,  1, 'transdim'],
          [ 0, -2, 'terra'],
          [ 0, -1, 'ice'],
          [ 1,  0, 'titanium'],
          [ 2, -1, 'transdim'],
        ]
      },
      {
        number: 9,
        planets: [
          [-2,  1, 'swamp'],
          [-1, -2, 'volcanic'],
          [-1,  0, 'titanium'],
          [ 1, -2, 'transdim'],
          [ 1,  0, 'gaia'],
          [ 2, -1, 'ice'],
        ]
      },
      {
        number: 10,
        planets: [
          [-2,  1, 'terra'],
          [-1, -1, 'desert'],
          [-1,  1, 'oxide'],
          [ 1, -2, 'transdim'],
          [ 1,  0, 'gaia'],
          [ 2, -1, 'transdim'],
        ]
      },
    ];

    const tilePositions = [
      [0,1],
      [0,2],
      [1,0],
      [1,1],
      [1,2],
      [2,0],
      [2,1],
      [2,2],
      [3,0],
      [3,1],
    ];


    /**
     * -------------------------------------------------------
     * Grid Functions
     * -------------------------------------------------------
     */

    // Build one of the 10 tiles given the coordinates of each planet
    function buildTile(number, rotation, tilePosition) {
      const tileSpec = tileSpecs.find(spec => spec.number === number);

      // Convert coordinates to cube
      const planets = tileSpec.planets.map(([x, y, planet]) => {
        let coordinates = Hex().toCube({x, y});

        // Rotate the coordinates {rotation} times clockwise
        for (let i = 1; i <= rotation; i++) {
          const {q, r, s} = coordinates;
          coordinates = {q:-r, r:-s, s:-q};
        }

        return {
          type: planet,
          coordinates,
        };
      });

      // Translate tile position to cube coordinates
      let translation = {q: 0, r: 0, s: 0};
      let [tilePositionX, tilePositionY] = tilePosition;
      for (let i = 0; i < tilePositionX; i++) {
        translation = {q: translation.q + tileShiftX.q, r: translation.r + tileShiftX.r, s: translation.s + tileShiftX.s};
      }
      for (let i = 0; i < tilePositionY; i++) {
        translation = {q: translation.q + tileShiftY.q, r: translation.r + tileShiftY.r, s: translation.s + tileShiftY.s};
      }
      
      const hexes = [];
      Grid.hexagon({
        radius: 2,
        onCreate: (hex => {
          const planet = planets.find(({coordinates}) => hex.q === coordinates.q && hex.r === coordinates.r && hex.s === coordinates.s);
          hexes.push({
            q: hex.q + translation.q,
            r: hex.r + translation.r,
            s: hex.s + translation.s,
            planet: planet ? planet.type : 'empty'
          })
        }),
      });

      return hexes;
    }


    /**
     * -------------------------------------------------------
     * Rendering Functions
     * -------------------------------------------------------
     */
    
     function render(grid) {
      // Begin render
      const draw = SVG().addTo('#grid').size('100%', '100%');
  
      // Reusable hexagon
      const hexSymbol = draw.symbol()
          .polygon(Hex().corners().map(({ x, y }) => `${x},${y}`))
          .fill('#212529')
          .stroke({ width: 1, color: '#999' })
  
      // Render tile
      grid.forEach(hex => {
          const { x, y } = hex.toPoint()
          draw.use(hexSymbol).translate(x, y);
          if (hex.planet !== 'empty') {
            draw.circle(planetSize).fill(planetColors[hex.planet]).translate(x + hex.width()/2 - planetSize/2, y + hex.height()/2 - planetSize/2);
          }
      })

      // Resize grid container
      const bbox = draw.bbox();
      draw.viewbox(bbox);
  
      const gridContainer = document.getElementById('grid');
      gridContainer.style.width = '100%';
      if (gridContainer.offsetWidth > bbox.width) {
        gridContainer.style.width = `${Math.ceil(bbox.width)}px`;
      }
    }

    /**
     * -------------------------------------------------------
     * Generation Logic
     * -------------------------------------------------------
     */

    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    // Combine all 10 tiles into a board
    shuffleArray(tilePositions);
    const board = Grid([...Array(10).keys()].flatMap((tileNumber, index) => {
      const rotation = Math.floor(Math.random() * 6);
      return buildTile(tileNumber + 1, rotation, tilePositions[index]);
    }));

    render(board);

    
  </script>
</body>
</html>