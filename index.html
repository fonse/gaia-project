<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gaia Project Board Generator</title>
</head>
<body>
  
  <main class="container">
    <div id="grid" style="margin: auto"></div>
  </main>

  <script src="static/svg.min.js"></script>
  <script src="static/honeycomb.min.js"></script>
  
  <script>
    /**
     * -------------------------------------------------------
     * Constants
     * -------------------------------------------------------
     */

    const Hex = Honeycomb.extendHex({
        size: 30,
        orientation: 'flat',
    });
    const Grid = Honeycomb.defineGrid(Hex);
    
    const planetSize = 30;
    const planetColors = {
      'terra': '#2080f0',
      'desert': '#f2ff00',
      'swamp': '#704100',
      'oxide': '#ff160a',
      'volcanic': '#ff9500',
      'ice': '#f8fff5',
      'titanium': '#6c757d',
      'transdim': '#a64dff',
      'gaia': '#00aa00',
    };
    const homePlanetTypes = Object.keys(planetColors).filter(type => type !== 'gaia' && type !== 'transdim');

    const tileShiftX = {q: 5, r: -2, s: -3};
    const tileShiftY = {q: 3, r: -5, s: 2};

    const tileSpecs = [
      {
        number: 1,
        planets: [
          [-2,  0, 'desert'],
          [-1, -1, 'swamp'],
          [ 0,  2, 'oxide'],
          [ 1, -1, 'terra'],
          [ 1,  1, 'volcanic'],
          [ 2, -0, 'transdim'],
        ]
      },
      {
        number: 2,
        planets: [
          [-1, -2, 'volcanic'],
          [-1,  0, 'swamp'],
          [-1,  1, 'oxide'],
          [ 0, -2, 'titanium'],
          [ 1, -1, 'ice'],
          [ 1,  1, 'transdim'],
          [ 2,  0, 'desert'],
        ]
      },
      {
        number: 3,
        planets: [
          [-1, -1, 'gaia'],
          [-1,  1, 'terra'],
          [ 0, -2, 'transdim'],
          [ 0,  2, 'desert'],
          [ 1,  0, 'ice'],
          [ 2,  0, 'titanium'],
        ]
      },
      {
        number: 4,
        planets: [
          [-2,  0, 'ice'],
          [-1,  0, 'volcanic'],
          [ 0, -2, 'titanium'],
          [ 0, -1, 'oxide'],
          [ 1,  0, 'swamp'],
          [ 2,  1, 'terra'],
        ]
      },
      {
        number: 5,
        planets: [
          [-1, -1, 'gaia'],
          [-1,  1, 'volcanic'],
          [ 0, -2, 'ice'],
          [ 0,  2, 'desert'],
          [ 2, -1, 'transdim'],
          [ 2,  0, 'oxide'],
        ]
      },
      {
        number: 6,
        planets: [
          [-1, -1, 'swamp'],
          [ 0,  1, 'gaia'],
          [ 1, -2, 'transdim'],
          [ 1, -1, 'terra'],
          [ 1,  1, 'transdim'],
          [ 2,  1, 'desert'],
        ]
      },
      {
        number: 7,
        planets: [
          [-2, -1, 'transdim'],
          [-1,  0, 'gaia'],
          [ 0, -1, 'oxide'],
          [ 0,  2, 'titanium'],
          [ 1, -2, 'swamp'],
          [ 1,  0, 'gaia'],
        ]
      },
      {
        number: 8,
        planets: [
          [-1,  0, 'volcanic'],
          [-1,  1, 'transdim'],
          [ 0, -2, 'terra'],
          [ 0, -1, 'ice'],
          [ 1,  0, 'titanium'],
          [ 2, -1, 'transdim'],
        ]
      },
      {
        number: 9,
        planets: [
          [-2,  1, 'swamp'],
          [-1, -2, 'volcanic'],
          [-1,  0, 'titanium'],
          [ 1, -2, 'transdim'],
          [ 1,  0, 'gaia'],
          [ 2, -1, 'ice'],
        ]
      },
      {
        number: 10,
        planets: [
          [-2,  1, 'terra'],
          [-1, -1, 'desert'],
          [-1,  1, 'oxide'],
          [ 1, -2, 'transdim'],
          [ 1,  0, 'gaia'],
          [ 2, -1, 'transdim'],
        ]
      },
    ];

    const tilePositions = [
      [0,1],
      [0,2],
      [1,0],
      [1,1],
      [1,2],
      [2,0],
      [2,1],
      [2,2],
      [3,0],
      [3,1],
    ];


    /**
     * -------------------------------------------------------
     * Grid Functions
     * -------------------------------------------------------
     */

    // Build one of the 10 tiles given the coordinates of each planet
    function buildTile(number, rotation, tilePosition) {
      const tileSpec = tileSpecs.find(spec => spec.number === number);

      // Convert coordinates to cube
      const planets = tileSpec.planets.map(([x, y, planet]) => {
        let coordinates = Hex().toCube({x, y});

        // Rotate the coordinates {rotation} times clockwise
        for (let i = 1; i <= rotation; i++) {
          const {q, r, s} = coordinates;
          coordinates = {q:-r, r:-s, s:-q};
        }

        return {
          type: planet,
          coordinates,
        };
      });

      // Translate tile position to cube coordinates
      let translation = {q: 0, r: 0, s: 0};
      let [tilePositionX, tilePositionY] = tilePosition;
      for (let i = 0; i < tilePositionX; i++) {
        translation = {q: translation.q + tileShiftX.q, r: translation.r + tileShiftX.r, s: translation.s + tileShiftX.s};
      }
      for (let i = 0; i < tilePositionY; i++) {
        translation = {q: translation.q + tileShiftY.q, r: translation.r + tileShiftY.r, s: translation.s + tileShiftY.s};
      }
      
      const hexes = [];
      Grid.hexagon({
        radius: 2,
        onCreate: (hex => {
          const planet = planets.find(({coordinates}) => hex.q === coordinates.q && hex.r === coordinates.r && hex.s === coordinates.s);
          hexes.push({
            q: hex.q + translation.q,
            r: hex.r + translation.r,
            s: hex.s + translation.s,
            planet: planet ? planet.type : 'empty',
            isCenter: hex.q === 0 && hex.r === 0 && hex.s === 0,
            tileNumber: number,
            tilePositionX,
            tilePositionY,
            rotation,
          })
        }),
      });

      return hexes;
    }

    // Calcualte the distance between two hexes
    function distance(hexFrom, hexTo) {
      return Math.max(Math.abs(hexFrom.q - hexTo.q), Math.abs(hexFrom.r - hexTo.r), Math.abs(hexFrom.s - hexTo.s));
    }

    // Check if the home planet distribution is balanced
    function calculateMinDistances(grid) {
      // Calculate distances between each pair of home planets
      const distances = {};
      homePlanetTypes.forEach(type => {
        distances[type] = {}
        homePlanetTypes.forEach(type2 => distances[type][type2] = []);
      });
      const minDistances = Object.assign({}, distances);
      
      grid.forEach(hex => {
        if (homePlanetTypes.includes(hex.planet)) {
          grid.forEach(otherHex => {
            if (hex === otherHex) return;
            if (!homePlanetTypes.includes(otherHex.planet)) return;

            distances[hex.planet][otherHex.planet].push(distance(hex, otherHex));
          });
        }
      });

      homePlanetTypes.forEach(type => {
        homePlanetTypes.forEach(type2 => {
          minDistances[type][type2] = Math.min(...distances[type][type2]);
        });
      });

      return minDistances;
    }


    /**
     * -------------------------------------------------------
     * Rendering Functions
     * -------------------------------------------------------
     */
    
     function render(grid) {
      // Begin render
      const draw = SVG().addTo('#grid').size('100%', '100%');
  
      // Reusable hexagon
      const hexSymbol = draw.symbol()
          .polygon(Hex().corners().map(({ x, y }) => `${x},${y}`))
          .fill('#212529')
          .stroke({ width: 1, color: '#999' })
  
      // Render tile
      grid.forEach(hex => {
        const { x: baseX, y: baseY } = hex.toPoint()
        const x = baseX + hex.tilePositionX * 4;
        const y = baseY - hex.tilePositionY * 4;
        
        const centerX = x + hex.width()/2;
        const centerY = y + hex.height()/2;

        draw.use(hexSymbol).translate(x, y);
        
        if (hex.planet !== 'empty') {
          draw.circle(planetSize).fill(planetColors[hex.planet]).translate(centerX - planetSize/2, centerY - planetSize/2);
        }

        if (hex.isCenter) {
          const text = draw.text(hex.tileNumber)
            .fill('#c0c0c0')
            .font({
              family: 'Helvetica',
              size: 20,
              weight: 'bold',
            });

          text.move(centerX - text.length()/2, centerY - 5);
          text.rotate(hex.rotation * 60, centerX, centerY);

          draw.polygon('0,5 10,5 5,0')
            .fill('#c0c0c0')
            .move(centerX - 5, centerY - 15)
            .rotate(hex.rotation * 60, centerX, centerY);
        }
      })

      // Resize grid container
      const bbox = draw.bbox();
      draw.viewbox(bbox);
  
      const gridContainer = document.getElementById('grid');
      gridContainer.style.width = '100%';
      if (gridContainer.offsetWidth > bbox.width) {
        gridContainer.style.width = `${Math.ceil(bbox.width)}px`;
      }
    }

    /**
     * -------------------------------------------------------
     * Generation Logic
     * -------------------------------------------------------
     */

    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    // Combine all 10 tiles into a board
    shuffleArray(tilePositions);
    const board = Grid([...Array(10).keys()].flatMap((tileNumber, index) => {
      const rotation = Math.floor(Math.random() * 6);
      return buildTile(tileNumber + 1, rotation, tilePositions[index]);
    }));

    const minDistances = calculateMinDistances(board);
    console.log(minDistances);

    render(board);

    
  </script>
</body>
</html>